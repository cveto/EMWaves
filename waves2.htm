<!DOCTYPE html>
<html>

<script>

// SOME VISIBLE LIGHT FREQUENCIES
var fgreen=565;			// THz 10^12	green color median frequency
var fred=442.5;			// THz 10^12	red   color median frequency
var fblue=640;			// THz 10^12	blue  color median frequency

var ftest=299.792458;	// freqency at which wavelength exzactly 1 micrometer and it lasts 3335.640952 attoseconds

var Amp = 20;		// Just to make it look presentable on the canvas.


// CANVAS PRESENTATION VARIABLES
var ctx;
var sampling=50; 		// SAMPLES PER PERIOD
var DPmm=50;			// DOTS PER MICROMETER OF WAVELENGTH REPRESENTED ON SCREEN

// TIME: t Ntime*delta_t.
var t=0;							// time in attoseconds
var Ntime=0;						
var delta_t_min=10;						// DO NOT CHANGE THIS - modify slowdown_factor instead.
									// TIME SAMPLING RATE OF SIGNAL, HOW MUCH REAL TIME HAS PASED BETWEEN 2 SNAPSHOTS?
									// e.g. at 300THZ, it takes the signal 3 femtoseconds to  travel the distance of 1 wavelength	
									// We want to see the signal traveling smoothly, so we set this to about 1/100th or however much computer lets us.
									// This is independent of the material.
									// To slow down the ray, we have to either 1: speed up animatino (can't do dynamically)
									// So I change the time sampling rate by modifying delta_t. MAx should be 1500attoseconds (fastes)

var slowdown_factor;				// Slowing down wave is done by increasing sample time.
var delta_t=delta_t_min*slowdown_factor;

var intervalms=20;					// How often the canvas is refreshed - every XY miliseconds (10ms = 100HZ)
									// GOING TO NEXT TIMESLOT EVERY XY MILISECONDS.


var xCenter1=350;
var yCenter1=350;


// WAVES

//  wave1[xstart0,ystart1,xrotate2,yrotate3,tilt4,raylength5,wavelength6,frequency7,Amplitude8,refractiveIndex9]
var wave1=["empty",  "empty",  "empty",  "empty", "empty", 5, "empty",   ftest, Amp,1];		// By default 2 and 3 are set to 1 and 2
var wave2=["empty", "empty", "empty", "empty", "empty", 5, "empty",   ftest,  Amp,1.6]		// by default 2 and 3 are ignored

// MATERIALS
var n1;
var n2;
var wall1=[418,118,430,1000];

// PLAYGROUND
var timer1=0;
var timer2=0;


var travelwaveI=0;

function init() {
	ctx= myCanvas.getContext('2d');
	setInterval(draw,intervalms);	 				// 10 milisecond - 100 per second
	//draw();
}

function calculate_wavelenght(fTHz,n) {	// Takes n and f in Thz
	var c0mmpms=299792458							// meters per second == micrometers per microseconds
	var lambda_micrometers=c0mmpms/n/fTHz/1000000;	// in micrometers
	//var lambda_nanometers=c0mmpms/n/fTHz/1000;		// in nanometers
	return lambda_micrometers;
}

function calculate_border_phase(distance_travelled,lambda) {	

	// What is the wavelenght of the wave?					2.0 um
	// lambda

	// What is the distance travelled in micrometers?  		6.8 um
	// distance_travelled.			

	// How many lambdas fit in to the distance traveled?	3.4
	var hmlfittd = distance_travelled/lambda;
	
	// How many whole lambdas fit in to this distance?		3
	var hmlfittd_whole=Math.floor(hmlfittd);
	
	// And the difference that doesnt fit is??				0.4 of a lambda
	var hmlfittd_left=hmlfittd-hmlfittd_whole;
	
	// And in radians, how much is that?					0.4*2PI
	var phase = hmlfittd_left*2*Math.PI;			// This should not exceed 2PI.. but it does

	return phase;
}

function drawRay(wave,ctx,xStart,yStart,tilt,phaseShift,n) {

	// Pulled 
	var fTHz=wave[7];							// f in TeraHerz 10^12
	var taas=1/fTHz*1000000;					// Time of one period in attoseconds
	var raylength = wave[5];					// length of wave in micrometers in the direction of movement for presentation purposes)
	var Amp=wave[8];							// Wave Amplitude - has no meaning, just to make it nice on the canvas
	
	// Calculated
	var lambda1=calculate_wavelenght(fTHz,n);	// get vavelenght in micrometers
	var numPeriodsToDraw=raylength/lambda1;		// depends on the length of the distance traveled
	
	// TIME TIME TIME
	//var w1=2*Math.PI*fTHz/1000000;				// Angular speed in rad/(10^18s) = rad/microsecond
	var w11=2*Math.PI*fTHz*1000000000000;			// Angular speed in rad/s
	var w11=2*Math.PI*fTHz/Math.pow(10,6);			// Angular speed in rad/attoseconds		
	
	
	var rotatex = xStart;			// By default the rotation is around the starting point of the wave
	var rotatey = yStart;
	
	// start drawing where?
	ctx.moveTo(xStart,yStart);	

	// rotate around what point?
	ctx.translate(rotatex,rotatey);		
	ctx.rotate(tilt * Math.PI / 180);
	ctx.translate(-rotatex,-rotatey);
	
	// Calculated
	var k1 = 2*Math.PI/lambda1;							// Wavenumber in 1/micrometers

	travelwaveI+=0.6
	

	

	
	// THIS SIMULATES HOW WAVE IS APPROACHING TO THE SUFACE.
	if (t<=taas*numPeriodsToDraw)	{
		var how_many_samples=sampling*t*fTHz/1000000;
	} else {
		var how_many_samples=sampling*numPeriodsToDraw;
	}
	
	
	for (var i=0;i<=how_many_samples;++i) {	// All is relative to wavelenght
	
		var x=i*lambda1/sampling;						// One wavelenght divided in XY samples, x is width between samples and depends on the wavelength.
		var mmppx=x*DPmm								// StretchFactor (How many pixels represents a micrometer of a wavelenght
		
		//--------------------
		var f1=Amp*Math.sin(k1*x-w11*t+phaseShift);		//
		//--------------------
		
		// Make the wave look like it's travelling from 0 without modifying the quation
		if(document.getElementById("markWaves").checked == '1'){	
			ctx.rect(xStart+mmppx,yStart+f1, 1, 1);		// Makes dots
			//ctx.lineTo(xStart+mmppx,yStart+f1);			// Connets lines
		}
		
		if(f1<-Amp*(0.999) && document.getElementById("markFronts").checked == false){							// Detecting peak.. one way of doing it
			ctx.rect(xStart+mmppx,yStart-25,0.5,50);
		}
	}

	// Rotate K.O. back
	ctx.translate(rotatex,rotatey);
	ctx.rotate(-tilt * Math.PI / 180);
	ctx.translate(-rotatex,-rotatey);	
}

function draw() {

	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");

	// TIME INFO
	// Time goes forward or backwards?
	slowdown_factor=document.getElementById("range_speed").value;
	delta_t=delta_t_min*slowdown_factor;
	document.getElementById("value_speed").innerHTML=slowdown_factor;

	ctx.beginPath();
	
	ctx.rect(30, 10, DPmm, 2);			// 1 micrometer
	ctx.rect(0, 350, 5000, 2);			// Horizontal Line
	ctx.rect(350, 0, 2,5000);
	
	// item: Wave 1
	// SET FREQUENCY FOR BOTH WAVES
	wave1[7]=document.getElementById("range_frequency1").value;
	wave2[7]=wave1[7];
	document.getElementById("value_frequency1").innerHTML=wave1[7];
	
	var n1=1;
	n1=document.getElementById("range_n1").value/100;
	document.getElementById("value_n1").innerHTML=n1;
	
	var theta1=15;							// Angle from vertical middle line
	theta1=document.getElementById("theta1").value;
	document.getElementById("value_theta1").innerHTML=theta1;

	var tilt=90-theta1;						// Angle from horizontal line... because Javascript
	var thetaRad=Math.PI/180*(theta1);		// Theta in radians
	
	// Strating point of second wave is the ending point of first wave.
	var xStart=xCenter1-wave1[5]*DPmm*Math.cos(tilt*Math.PI/180);
	var yStart=yCenter1-wave1[5]*DPmm*Math.sin(tilt*Math.PI/180);

	drawRay(wave1,ctx,xStart,yStart,tilt,0,n1);
	

	////////////////
	// item: Wave 2
	
	// Where did Wave1 end, wave2 will continue from there
	var xEndWave1 = xStart+wave1[5]*DPmm*Math.cos(tilt*Math.PI/180);
	var yEndWave1 = yStart+wave1[5]*DPmm*Math.sin(tilt*Math.PI/180);
	
	// Material2 properties
	var n2=1;
	n2=document.getElementById("range_n2").value/100;
	document.getElementById("value_n2").innerHTML=n2;
	
	
	var theta2rad=Math.asin(Math.sin(thetaRad)*n1/n2);		// Sneels Law
	var tilt2=90-theta2rad*180/Math.PI;
	
	// PHASE CALCULATION.. where does ray2 start and is the phase shifted for reflected wave?
	// At what phase does ray2 start (where ray1 ends)
	var wave2_phase=0;
	
	// Shift phase for total reflection
	if (isNaN(theta2rad)) {				// Total reflection,Snells law 
		theta2rad=thetaRad-Math.PI/2;
		tilt2=theta2rad*180/Math.PI;
		//wave2_phase-=Math.PI/2
	} 
	
	var deleteme=calculate_wavelenght(wave1[7],n1);
	wave2_phase=calculate_border_phase(wave1[5],deleteme);
	
	drawRay(wave2,ctx,xEndWave1,yEndWave1,tilt2,wave2_phase,n2);
	
	
	// Clear Image
	ctx.clearRect(0,0, 3000,3000);
	ctx.stroke();


	// Time is actually flowing?
	if (document.getElementById("button_pause").value==1) 	{
		Ntime+=1;
		t+=delta_t
	}
	
	document.getElementById("value_time").innerHTML=t/1000;
}

function pause_time() {
	if (document.getElementById("button_pause").value==0) {
	
		document.getElementById("button_pause").value=1;			// WHY IS THIS necessary again? To know if time is flowing or not.
		document.getElementById("button_pause").innerHTML="PAUSE TIME"
		timer1=timer2;
		timer2=0;
		document.getElementById("value_timer").innerHTML="";

	} else {
		document.getElementById("button_pause").value=0
		document.getElementById("button_pause").innerHTML="UNPAUSE TIME"
		timer2=t;
		var time_passed=(timer2-timer1)/1000;
		
		document.getElementById("value_timer").innerHTML=Math.floor(time_passed*1000)/1000;
	}
}

function reset_time() {
	t=0;
	Ntime=0;
}
</script>

<body onLoad="init();">
A:<span id="test1">ready</span></br>
B:<span id="test2">ready</span></br></br>
<div id="test3" value=10></div>

<button id="button_reset" onclick="reset_time()">RESET TIME</button><br />
FREQUENCY: <span id="value_frequency1"></span>THz<input type="range" id="range_frequency1" min="0" max="2000" value="260"> <br/>
THETA1: <span id="value_theta1"></span><input type="range" id="theta1" min="0" max="90" value="30"> <br/>
SPEED: x<span id="value_speed"></span> <input type="range" id="range_speed" min="1" max="40" value="2"><button id="button_pause" value="1" onclick="pause_time()">PAUSE</button></br>
n1: <input type="range" id="range_n1" min="0" max="300" value="100"><span id="value_n1"></span></br>
n2: <input type="range" id="range_n2" min="0" max="300" value="160"><span id="value_n2"></span></br>

TIME: [femtoseconds (10^-15) ]  <span id="value_time"></span> | <span id="value_timer"></span> <br />
Snakies: <input type="checkbox" id="markWaves" checked="1"> | Fronts: <input type="checkbox" id="markFronts" checked="true"> | 
GRAY LINE is 1 micrometer
<canvas id="myCanvas" width="3000" height="3000" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>


</body>
</html>
