<!DOCTYPE html>
<!-- Avtor: Florjan Praprotnik -->

<html>
<head>
<style>
body {
  background-color: linen;
}
input[type="range"] {
  width:400px;
}


/*MAIN PAGE DIVIDERS*/

* {
  box-sizing: border-box;
}

.column {
  float: left;
  min-width: 500px;
  min-height: 50px;
  /*border: 3px solid #73AD21;*/

}

.row {
   /*border: 3px solid blue;  */
   width: 1800px; 
   min-height:50px;
   padding:5px;
}

	/* Clear floats after the columns */
	.row:after {
	  content: "";
	  display: table;
	  clear: both;
	}
		#levi {
		  max-width: 580px;
		  padding: 25px;
		  word-wrap: break-word;
		}
		
		#desni {
		  width: 1200px;
		  height: 1800px;
		  float: left;
		  position: relative;
		  /*border: 3px solid #73AD21;*/
		}

			#zadej {
			  width: 100%;
			  height: 100%;
			  position: absolute;
			  top: 0;
			  left: 0;
			}
			#spredej {
			  width: 100%;
			  height: 100%;
			  position: absolute;
			  top: 0;
			  left: 0;
			  z-index: 10;
		}


/* */
#test_canvas {
  visibility: hidden;
}

/* */
#range_polarisation {
  width: 40px;
}



/*POPUPS*/
.white_content_backup {
  display: none;
  position: absolute;
  top: 50%;
  left: 15%;
  width: 400px;
  height: 300px;
  padding: 16px;
  border: 16px solid gray;
  background-color: linen;
  z-index: 1002;
  overflow: auto;
}

.white_content {
  display: none;
  position: relative;
  top: 0;
  left: 0px;
  width: 400px;
  height: 250px;
  padding: 8px;
  border: 8px solid gray;
  background-color: linen;
  z-index: 1002;
  overflow: auto;
}


/*MATH EQUATIONS - https://code-boxx.com/math-equations-html*/.. .. Not yet implemented
</style>
</head>


<script>
// CONSTANTS		
var c0mmpatts=299792458*Math.pow(10,9)						// Speed of light - micrometers per atoseconds


// SIGNAL			
var fgreen=565;												// THz 10^12	green color median frequency
var fred=442.5;												// THz 10^12	red   color median frequency
var fblue=640;												// THz 10^12	blue  color median frequency
var ftest=299.792458;										// freqency at which wavelength is exzactly 1 micrometer and its period is 3335.640952 attoseconds		
var Amp = 20;												// Just to make it look presentable on the canvas.
var wave1=[ftest,  5, Amp];									

		
// CANVAS VARIABLES		
var sampling=100; 											// SAMPLES PER MICROMETER. This has nothing to do with presentation on the screen
var DPmm=50;												// DOTS PER MICROMETER (resolution).. Dont change this, it will get messy

var xCenter1=DPmm*6;											// Border between rays
var yCenter1=DPmm*8.5;
var canvasWidth=DPmm*24;
var canvasHeight=canvasWidth*Math.sqrt(2);

// TIME: t=t+delta_t = t + delta_t*slowdown_factor
var t=0;													// time in attoseconds since the beginnig of simulation
var delta_t_min=10;											// DO NOT CHANGE THIS - modify slowdown_factor instead.
															// TIME SAMPLING RATE OF SIGNAL, HOW MUCH REAL TIME HAS PASED BETWEEN 2 SNAPSHOTS?
															// e.g. at 300THZ, it takes the signal 3 femtoseconds to  travel the distance of 1 wavelength	
															// We want to see the signal traveling smoothly, so we set this to about 1/100th or however much computer lets us.
															// This is independent of the material.
															// To slow down the ray, we have to either 1: speed up animation (can't do dynamically unfortunately)
															// So I change the time sampling rate by modifying delta_t. Max should be 1500attoseconds based on the frequencies used
var slowdown_factor;										// Slowing down wave is done by increasing sample time.
var delta_t=delta_t_min*slowdown_factor;					// TIME RESOLUTION - this variable is redefined in function draw
					
var intervalms=20;											// How often the canvas is refreshed - every XY miliseconds (10ms = 100HZ)
															// every intervalms the compute has to calculate the whole image.. can he do it in 20ms?


// MATERIALS
	var n1;													// As set on the sliders
	var n2;													// As set on the sliders

	// Theese guys needed as a global variable because - dispersive media - on click the button must get access to N
	var n1ray1;												// For dispersive media
	var n1ray2;
	var n2ray1;
	var n2ray2;

// STOPWATCH
var stopwatch1=0;
var stopwatch2=0;

// PLAYGROUND
var strk_style_before;
var timedown;
// LOADS WITH THML

// POPUPS:



function init() {
	// KEYBOARD LISTENERS
	
		// DISABLE DEFAULT KEYBOARD BEHAVIOUR
		window.addEventListener("keydown", function(e) {
			// space and arrow keys
			if([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
				e.preventDefault();
			}
		}, false);
		
	
		// IF HOLDING DOWN
		document.body.onkeydown = function(e){
			if (e.keyCode == 39){									// RIGHT DECREASES THETA
				var theta=Number(document.getElementById("theta1").value);
				setThetaAngle(theta-1);
			} else if (e.keyCode == 37){							// LEFT INCREASES THETA
				var theta=Number(document.getElementById("theta1").value);
				setThetaAngle(theta+1);
			} else if (e.keyCode == 32){							// SPACEBAR 
					pause_time();
			} else if (e.keyCode == 84){							// T for theta = 0
					setThetaAngle(0);
			} else if (e.keyCode == 66){							// B for Brewster windows
					setBrewsterAngle();
			} else if (e.keyCode == 86){							// V for totalni odboj
					setCriticalAngle();
			} else if (e.keyCode == 82){							// spacebar
					reset_time();
			} else if (e.keyCode == 190){							// pika
					var n2=Number(document.getElementById("range_n2").value);
					document.getElementById("range_n2").value=n2+1;
			} else if (e.keyCode == 188){							// pika
					var n2=Number(document.getElementById("range_n2").value);
					document.getElementById("range_n2").value=n2-1;
			}else if (e.keyCode == 38){							// ARROW UP
				var fTHz1=Number(document.getElementById("range_frequency1").value);
					setFrequencyRay1(fTHz1+1);
			} else if (e.keyCode == 40){							// ARROW DOWN
				var fTHz1=Number(document.getElementById("range_frequency1").value);
					setFrequencyRay1(fTHz1-1);
			} else if (e.keyCode == 80){							// P for polarisation
				var pol_choice=document.getElementById("range_polarisation").value;
				if (pol_choice==0) {
					document.getElementById("range_polarisation").value=1;
				} else {
					document.getElementById("range_polarisation").value=0;
				} 
			} 
		}
		


	
	// Set fronts to unchecked - There apparently isn't a checked="0" which would cause it to be unchecked?
	document.getElementById("markFronts").checked=1;
	document.getElementById("markFields").checked=0;
	document.getElementById("markWaves").checked=0;
	
	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// Backround Canvas
	var canvas2 = document.getElementById("background_canvas");
	canvas2.width=canvasWidth;
	canvas2.height=canvasHeight;
	var ctx2 = canvas2.getContext("2d");	
	
	// KARO ZVEZEK
		var num_squares_hor=canvasWidth/(DPmm/2)-4;
		var num_squares_ver=Math.floor(canvasHeight/(DPmm/2)-6);
		drawMathPaper(DPmm,DPmm,num_squares_hor,num_squares_ver,DPmm/2,ctx2);							// karo zvezek
																										//	block_startX,block_startY,blocks_vertical,blocks_horizontal,block_width,ctx
	// PAPER FRAME
		ctx2.setLineDash([]);						// Normals traight line
		ctx2.beginPath();
		ctx2.strokeStyle = '#585858';	
		ctx2.rect(0, 0, canvas2.width, canvas2.height);								// frame
		ctx2.stroke();
		
	// 1 micrometer reference
		ctx2.beginPath();
		ctx2.strokeStyle = 'red';	
		ctx2.rect(DPmm, DPmm*5/4, DPmm, 1);	
		ctx2.font = "20px Lucida Console";
		fillTextkaro("1μm",3,1,ctx2,DPmm);
		ctx2.stroke();

		
	// Single mode fibre core 9um
		ctx2.beginPath();
		ctx2.rect(DPmm, DPmm*7/4, 9*DPmm, 1);										// 1 micrometer reference
		fillTextkaro(" 9μm - ŠIRINA JEDRA ENORODOVNEGA OPTIČNEGA VLAKNA",19,2,ctx2,DPmm);
		ctx2.stroke();

	//  LINES
		ctx2.beginPath();
		ctx2.strokeStyle = '#585858';	
		drawCrossBorder(xCenter1,yCenter1,ctx2,DPmm);
		drawCrossBorder(xCenter1+6*DPmm,yCenter1,ctx2,DPmm);
		drawCrossBorder(xCenter1+12*DPmm,yCenter1,ctx2,DPmm);
		ctx2.stroke();

	// 1 micrometer reference
		ctx2.beginPath();
		ctx2.fillStyle = "red";							// FILLSTYLE FOR TEXT; STROKESTYLE FOR LINES
		fillTextkaro("ŽAREK 1",9,5,ctx2,DPmm);	ctx2		// 4 desno, pet dol
		fillTextkaro("ŽAREK 2",21,5,ctx2,DPmm);	ctx2
		fillTextkaro("ŽAREK 1 + ŽAREK 2",31,5,ctx2,DPmm);	ctx2
		ctx2.stroke();
		

	//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	// Animated Canvas
	canvas1 = document.getElementById("myCanvas");
	canvas1.width=canvasWidth;
	canvas1.height=canvasHeight;
	
	var ctx1 = canvas1.getContext("2d");
	//setInterval(draw,intervalms);									// Calls function draw every intervalms miliseconds
	setInterval( function() { draw(ctx1,canvas1); }, intervalms );
	//draw();
	
}

// Places  text relative to the math square
function fillTextkaro(tekst,kvadratek_x,kvadratek_y,ctx,DPmm) {
	ctx.fillText(tekst, DPmm+(kvadratek_x-1)*DPmm/2+DPmm/20,DPmm+(kvadratek_y)*DPmm/2-DPmm/10);
}

function drawCrossBorder(x,y,ctx2,DPmm) {
	var width=5.5
	ctx2.rect(x-DPmm*width/2, y , DPmm*width, 2);		// Horizontal Line
	ctx2.rect(x, y-DPmm*3, 2, DPmm*6);		// Vertical line
}

// FUNCTION THAT IS BEEING CALLED EVERY XYZ MILISECOND FOR ANIMATION
function draw(ctx1,canvas) {

	// CLEAR CANVAS
		ctx1.clearRect(0,0, canvas.width,canvas.height);								
	
    //---- SET SIMULATION SAMPLING
			sampling=document.getElementById("range_sampling").value;			// SETS GLOBAL VARIABLE
			document.getElementById("value_sampling").innerHTML=sampling;
	
	//---- TIME INFO ----
		// GET SPEED FROM USER, APPLY SPEED, SHOW USER WHAT SPEED IS CURRENTLY IN THE RUN
			slowdown_factor=document.getElementById("range_speed").value;
			delta_t=delta_t_min*slowdown_factor;
			document.getElementById("value_speed").innerHTML=slowdown_factor;
			
		// Show timer
		document.getElementById("value_timer").innerHTML=((t-stopwatch1)/1000).toFixed(2);		// Show timer

		// Time is actually flowing?
		if (document.getElementById("button_pause").value==1) 	{
			t+=delta_t
		}
		document.getElementById("value_time").innerHTML=(t/1000).toFixed(2);

	// DRAW POLARIZATION ARROW
		// polarization arrows
			ctx1.beginPath();
			ctx1.strokeStyle = '#585858';	
			ctx1.lineWidth = 3;
			drawLineWithArrows(0.5*DPmm,4*DPmm,2*DPmm,5.5*DPmm,15,15,false,true,ctx1)		// Carefu, strok inside already
			ctx1.stroke();
			
				
			if (document.getElementById("range_polarisation").value==0) {
				ctx1.beginPath();
				ctx1.strokeStyle = 'red';	
				drawLineWithArrows(1.25*DPmm,4.25*DPmm,1.25*DPmm,5.25*DPmm,5,5,true,true,ctx1)		// Carefu, strok inside already
				ctx1.stroke();
			
				ctx1.beginPath();
				ctx1.strokeStyle = '#585858';	
				drawLineWithArrows(0.85*DPmm,4.95*DPmm,1.65*DPmm,4.55*DPmm,5,5,true,true,ctx1)		// Carefu, strok inside already
				ctx1.stroke();
			} else {
				ctx1.beginPath();
				ctx1.strokeStyle = 'red';	
				drawLineWithArrows(0.85*DPmm,4.95*DPmm,1.65*DPmm,4.55*DPmm,5,5,true,true,ctx1)		// Carefu, strok inside already
				ctx1.stroke();
		
				ctx1.beginPath();
				ctx1.strokeStyle = '#585858';	
				drawLineWithArrows(1.25*DPmm,4.25*DPmm,1.25*DPmm,5.25*DPmm,5,5,true,true,ctx1)		// Carefu, strok inside already
				ctx1.stroke();
			}

	//  HIDE settings setting n2 of second ray, if its no chosen
		// IF RADIO BUTTON 
		if (document.getElementById("radio_id_manual").checked == true) {
				// SET VISIBILITY OF RANGE TO VISIBLE
			document.getElementById("hidden_2nz2").style.visibility = 'visible';
		} else {
			document.getElementById("hidden_2nz2").style.visibility = 'hidden';

		}
		
		// IF DISPERSIVE MEDIA CHOSEN BUT NOT SPECIAL ONES
		if (document.getElementById("radio_id_onlytopdispersive").checked == true || document.getElementById("radio_id_onlybottmdispersive").checked == true || document.getElementById("radio_id_bothdispersive").checked == true) {
				document.getElementById("hidden_dispersivity").style.visibility = 'visible';
		} else {
				document.getElementById("hidden_dispersivity").style.visibility = 'hidden';
		}

	
		// DRAW BOTH RAYS
		//(fTHz,raylength,locationx,locationy,Amp)
		// Source of Frequency?
		
		// Get frequency for left most wave
	
		// LEFT FREQUENCY RAY
		var fTHz=document.getElementById("range_frequency1").value;
		document.getElementById("value_frequency1").innerHTML=fTHz;
		
		var fTHz2=document.getElementById("range_frequency2").value;
		document.getElementById("value_frequency2").innerHTML=fTHz2;		
		
		// Material Above
		n1=document.getElementById("range_n1").value/100;
		document.getElementById("value_n1").innerHTML=n1;
		
		// Material below
		n2=document.getElementById("range_n2").value/100;
		document.getElementById("value_n2").innerHTML=n2;

		// Material below for ray 2 if enabled
		n2z2=document.getElementById("range_n2z2").value/100;
		document.getElementById("value_n2z2").innerHTML=n2z2;


		// IS MEDIA DISPERSIVE; WHICH AND HOW?
			// check which option is selected
			var radios = document.getElementsByName('radio_dispersion');
			var dispersivity=document.getElementById('range_dispersion').value; 		// dispersivity is something I Made up - mainy, how mow much does the light "spread" depending on the frequency.

			for (var i = 0, length = radios.length; i < length; i++) {
				// Non dispersive media
				if (radios[0].checked) {
					n1ray1=n1;
					n1ray2=n1;
					n2ray1=n2;
					n2ray2=n2;
					break;
				
				// TOP Media Dispersive
				} else if (radios[1].checked) {
					n1ray1=getDispersiveN(n1,fTHz,dispersivity);	
					n1ray2=getDispersiveN(n1,fTHz2,dispersivity);	
					n2ray1=n2;	
					n2ray2=n2;	
					break;
				
				// BOTTOM Media Dispersive
				} else if (radios[2].checked) {
					n1ray1=n1;	
					n1ray2=n1;
					n2ray1=getDispersiveN(n2,fTHz,dispersivity);		
					n2ray2=getDispersiveN(n2,fTHz2,dispersivity);	
					break;
					
				// BOTH Media Dispersive
				} else if (radios[3].checked) {
					n1ray1=getDispersiveN(n1,fTHz,dispersivity);	
					n1ray2=getDispersiveN(n1,fTHz2,dispersivity);	
					n2ray1=getDispersiveN(n2,fTHz,dispersivity);		
					n2ray2=getDispersiveN(n2,fTHz2,dispersivity);	
					break;
					
				// Specially dispersive media on which all wavelenghts are the same
				} else if (radios[4].checked) {
					n1ray1=n1;
					n1ray2=n1;	
					n2ray1=500/fTHz;
					n2ray2=500/fTHz2;	
					break;
				// If we want to set n for ray 1 and ray 2 separately
				} else if (radios[5].checked) {
					n1ray1=n1;
					n1ray2=n1;	
					n2ray1=n2;
					n2ray2=n2z2;	
					break;
				}
			}		
	
	

		// Left most 3 rays. Saving just for the summed wav. It's an array of 2 arrays
		ctx1.beginPath();
		ctx1.strokeStyle = "purple";
		
		// COLOR
		
		var arrays_leftmost=draw2rays(fTHz,wave1[1],xCenter1,yCenter1,15,n1ray1,n2ray1,ctx1);
		ctx1.stroke();

		// Middle 3 rays ray
		ctx1.beginPath();
		var arrays_middle=draw2rays(fTHz2,wave1[1],xCenter1+300,yCenter1,15,n1ray2,n2ray2,ctx1);		
		ctx1.stroke();
		// Sum of leftmost and middle ray. Needs raylength to get starting position	

		// RIGHT MOST RAY = RAY 1 + RAY 2
		ctx1.beginPath();
		drawSummedRayfromArray(arrays_leftmost,arrays_middle,xCenter1+600,yCenter1,wave1[1],ctx1);		//arrays, arrays2, locX, locY, raylength
		ctx1.stroke();
		
		
		
		// DRAW LABELS ON CANVAS
			// REFRACTIVE INDEX
			ctx1.beginPath();
			ctx1.fillStyle = "green";
			ctx1.font = "bold 15px Lucida Console";
			fillTextkaro("n1(" + fTHz + " THz)= "+Math.round(n1ray1*100)/100,1,4,ctx1,DPmm) 
			fillTextkaro("n1(" + fTHz2 + " THz)= "+Math.round(n1ray2*100)/100,1,5,ctx1,DPmm) 
			fillTextkaro("n2 (" + fTHz + " THz)= "+Math.round(n2ray1*100)/100,1,17,ctx1,DPmm) 
			fillTextkaro("n2 (" + fTHz2 + " THz)= "+Math.round(n2ray2*100)/100,1,18,ctx1,DPmm) 
			ctx1.stroke();	
			
			// THETA
			fillTextkaro("Θ",10.2,11,ctx1,DPmm) 
			fillTextkaro("Θr",11.1,20,ctx1,DPmm) 

			if (document.getElementById("showCalculations").checked==1) { 	//Disabling of too much
				// -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+v
				//OTHER THINGS ZAREK 1
				var c0=299792458*Math.pow(10,-9);									// Speed of light - micrometers per femtoseconds
				var c0zg1=c0/n1ray1;							
				var c0sp1=c0/n2ray1;
				var lambda_zg1=c0/(fTHz*n1ray1)*1000;								// in micrometers
				var lambda_sp1=c0/(fTHz*n2ray1)*1000;								// in micrometers
				var omega1=2*Math.PI*fTHz/Math.pow(10,3);      						// rad/fs
				var kzg1=2*Math.PI/lambda_zg1;				  		// rad/um
				var ksp1=2*Math.PI/lambda_sp1;
				var criticalAngle1=findCriticalAngle(n1ray1,n2ray1);
				var brewsterAngle1=findBresterAngle(n1ray1,n2ray1);
				var theta1deg=document.getElementById("theta1").value/10;
				var theta1rad=theta1deg*Math.PI/180;
				var reflectance1P=calculateReflectance(n1ray1,n2ray1,theta1rad,0);
				var reflectance1S=calculateReflectance(n1ray1,n2ray1,theta1rad,1);
				var pozY1=30;
				var pozX1=2;
				var angle_refraction_ray1deg=Math.asin(Math.sin(theta1rad)*n1ray1/n2ray1)*180/Math.PI;

				
				// HTML INFORMING FOR BUTTON
				if (isNaN(criticalAngle1)) {	
					document.getElementById("message_noCriticalAngle").innerHTML="Kritični kot za žarek 1 obstaja";
				} else {
					document.getElementById("message_noCriticalAngle").innerHTML="";
				}
				
				ctx1.beginPath();
				ctx1.fillStyle = "red";
				ctx1.font = "bold 22px Lucida Console";
				
				fillTextkaro("ŽAREK 1",pozX1,pozY1-2,ctx1,DPmm) 	
				ctx1.stroke();	
				
				ctx1.beginPath();
				ctx1.fillStyle = "#303030";

				fillTextkaro("f[žarek 1] = "+fTHz+" THz",pozX1,pozY1,ctx1,DPmm) 	
				
				fillTextkaro("Θ = "+theta1deg+"°",pozX1,pozY1+2,ctx1,DPmm); 	
				fillTextkaro("Θr = "+angle_refraction_ray1deg.toFixed(1)+"°",pozX1+6,pozY1+2,ctx1,DPmm); 	

				fillTextkaro("ΘB = "+brewsterAngle1+"°",pozX1,pozY1+3,ctx1,DPmm); 	
				fillTextkaro("ΘC = "+criticalAngle1+"°",pozX1,pozY1+4,ctx1,DPmm); 								

				fillTextkaro("Ts = "+Math.round(reflectance1S*1000)/1000,pozX1,pozY1+6,ctx1,DPmm); 
				fillTextkaro("Tp = "+Math.round(reflectance1P*1000)/1000,pozX1,pozY1+7,ctx1,DPmm); 
				
				// MEDIUM ON TOP
				fillTextkaro("c[\u21D1]= "+(c0zg1).toFixed(9)+" μm/fs = "+(1/n1ray1).toFixed(3)+"\u00B7c0",pozX1,pozY1+9,ctx1,DPmm);
				fillTextkaro("λ[\u21D1]= "+lambda_zg1.toFixed(3)+" μm",pozX1,pozY1+10,ctx1,DPmm);  // 2PI * f * n / c
				fillTextkaro("k[\u21D1]= "+kzg1.toFixed(3)+" rad/μm",pozX1,pozY1+11,ctx1,DPmm);  
				fillTextkaro("ω[\u21D1]= "+omega1.toFixed(3)+" rad/fs",pozX1,pozY1+12,ctx1,DPmm);  
				fillTextkaro("ω/k[\u21D1]= "+(omega1/kzg1).toFixed(9)+" μm/fs",pozX1,pozY1+13,ctx1,DPmm); 			


				// MEDIUM ON BOTTOM
				fillTextkaro("c[\u2B07]= "+(c0sp1).toFixed(9)+" μm/fs = "+(1/n2ray1).toFixed(3)+"\u00B7c0",pozX1,pozY1+15,ctx1,DPmm);	
				fillTextkaro("λ[\u2B07]= "+lambda_sp1.toFixed(3)+" μm",pozX1,pozY1+16,ctx1,DPmm); 
				fillTextkaro("k[\u2B07]= "+ksp1.toFixed(3)+" rad/μm",pozX1,pozY1+17,ctx1,DPmm); 
				fillTextkaro("ω[\u2B07]= "+omega1.toFixed(3)+" rad/fs",pozX1,pozY1+18,ctx1,DPmm);
				fillTextkaro("ω/k[\u2B07]= "+(omega1/ksp1).toFixed(9)+" μm/fs",pozX1,pozY1+19,ctx1,DPmm); 	
				



				//OTHER THINGS ZAREK 2
				// -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+v

				var c0=299792458*Math.pow(10,-9);									// Speed of light - micrometers per femtoseconds
				var c0zg2=c0/n1ray2;							
				var c0sp2=c0/n2ray2;
				var lambda_zg2=c0/(fTHz2*n1ray2)*1000;								// in micrometers
				var lambda_sp2=c0/(fTHz2*n2ray2)*1000;								// in micrometers
				var omega2=2*Math.PI*fTHz2/Math.pow(10,3);      					// rad/fs
				var kzg2=2*Math.PI/lambda_zg2;				  						// rad/um
				var ksp2=2*Math.PI/lambda_sp2;
				var pozX2=25
				var criticalAngle2=findCriticalAngle(n1ray2,n2ray2);
				var brewsterAngle2=findBresterAngle(n1ray2,n2ray2);
				var theta2deg=theta1deg;
				var theta2rad=theta1rad;
				var reflectance2P=calculateReflectance(n1ray2,n2ray2,theta1rad,0);
				var reflectance2S=calculateReflectance(n1ray2,n2ray2,theta1rad,1);
				var messageGroupVelocity="Rezultat smiselen le, če ω1 ≈ ω2 in k1 ≈ k2  oziroma B < fc";
				var angle_refraction_ray2deg=Math.asin(Math.sin(theta1rad)*n1ray2/n2ray2)*180/Math.PI;

				//  7 fucking lined to change the font color of one text
				ctx1.beginPath();
				ctx1.fillStyle = "red";
				fillTextkaro("ŽAREK 2",pozX2,pozY1-2,ctx1,DPmm) 	
				ctx1.stroke();	
				ctx1.beginPath();
				ctx1.fillStyle = "#303030";


				fillTextkaro("f[žarek 2] = "+fTHz2+" THz",pozX2,pozY1,ctx1,DPmm) 		
				
				fillTextkaro("Θ = "+theta2deg+"°",pozX2,pozY1+2,ctx1,DPmm); 
				fillTextkaro("Θr = "+angle_refraction_ray2deg.toFixed(1)+"°",pozX2+6,pozY1+2,ctx1,DPmm); 	
				fillTextkaro("ΘB = "+brewsterAngle2+"°",pozX2,pozY1+3,ctx1,DPmm); 					
				fillTextkaro("ΘC = "+criticalAngle2+"°",pozX2,pozY1+4,ctx1,DPmm); 								
				
				fillTextkaro("Ts = "+Math.round(reflectance2S*1000)/1000,pozX2,pozY1+6,ctx1,DPmm); 
				fillTextkaro("Tp = "+Math.round(reflectance2P*1000)/1000,pozX2,pozY1+7,ctx1,DPmm); 				
				
				// MEDIUM ON TOP
				fillTextkaro("c[\u21D1]= "+(c0zg2).toFixed(9)+" μm/fs = "+(1/n1ray2).toFixed(3)+"\u00B7c0",pozX2,pozY1+9,ctx1,DPmm);
				fillTextkaro("λ[\u21D1]= "+lambda_zg2.toFixed(3)+" μm",pozX2,pozY1+10,ctx1,DPmm);  // 2PI * f * n / c
				fillTextkaro("k[\u21D1]= "+kzg2.toFixed(3)+" rad/μm",pozX2,pozY1+11,ctx1,DPmm);  
				fillTextkaro("ω[\u21D1]= "+omega2.toFixed(3)+" rad/fs",pozX2,pozY1+12,ctx1,DPmm);  
				fillTextkaro("ω/k[\u21D1]= "+(omega2/kzg2).toFixed(9)+" μm/fs",pozX2,pozY1+13,ctx1,DPmm); 			
				
				// MEDIUM ON BOTTOM
				fillTextkaro("c[\u2B07]= "+(c0sp2).toFixed(9)+" μm/fs = "+(1/n2ray2).toFixed(3)+"\u00B7c0",pozX2,pozY1+15,ctx1,DPmm);
				fillTextkaro("λ[\u2B07]= "+lambda_sp2.toFixed(3)+" μm",pozX2,pozY1+16,ctx1,DPmm); 
				fillTextkaro("k[\u2B07]= "+ksp2.toFixed(3)+" rad/μm",pozX2,pozY1+17,ctx1,DPmm); 
				fillTextkaro("ω[\u2B07]= "+omega2.toFixed(3)+" rad/fs",pozX2,pozY1+18,ctx1,DPmm); 
				fillTextkaro("ω/k[\u2B07]= "+(omega2/ksp2).toFixed(9)+" μm/fs",pozX2,pozY1+19,ctx1,DPmm); 			


				//OTHER THINGS SKUPINSKA HITROST SEŠTETI ŽAREK
				// -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+				
				var pozY3=pozY1+22;
				
				var deltaomegasp=omega2-omega1;
				var deltaksp=ksp2-ksp1;

				var deltaomegazg=omega2-omega1;
				var deltakzg=kzg2-kzg1;				
				
				// ČE je nan, potem je skupinska hitrost enaka fazni
				if (isNaN(parseFloat("group_speed_top"))) {
					group_speed_top=c0zg1;					// The zero divided by zero, this means that it's the same signal summed twice
				}
				
				if (isNaN(parseFloat("group_speed_bot"))) {
					group_speed_bot=c0sp1;					// The zero divided by zero, this means that it's the same signal summed twice
				}
				
				var group_speed_top=deltaomegazg/deltakzg;			
				var group_speed_bot=deltaomegasp/deltaksp;
				var c0toGroupSpeedBot=Math.round(group_speed_bot/c0*1000000)/1000000;				// HOw fast is group speed compared to speed of light in vacum
				var c0toGroupSpeedTop=Math.round(group_speed_top/c0*1000000)/1000000;				// HOw fast is group speed compared to speed of light in vacum


				ctx1.beginPath();
				ctx1.fillStyle = "red";
				fillTextkaro("SEŠTETI ŽAREK:",pozX1+2,pozY3,ctx1,DPmm); 
				ctx1.stroke();	
				ctx1.beginPath();
				ctx1.fillStyle = "#303030";
				
				
				fillTextkaro("Δω[\u2B07]= "+deltaomegasp.toFixed(9)+" μm/fs",pozX1+5,pozY3+2,ctx1,DPmm); 			
				fillTextkaro("Δk[\u2B07]= "+deltaksp.toFixed(9)+" μm/fs",pozX1+5,pozY3+3,ctx1,DPmm); 

				fillTextkaro("Δω[\u21D1]= "+deltaomegazg.toFixed(9)+" μm/fs",pozX1+24,pozY3+2,ctx1,DPmm); 			
				fillTextkaro("Δk[\u21D1]= "+deltakzg.toFixed(9)+" μm/fs",pozX1+24,pozY3+3,ctx1,DPmm); 
				

				fillTextkaro(messageGroupVelocity,pozX1+2,pozY3+22,ctx1,DPmm); 			
				fillTextkaro("Δω/Δk[\u21D1]= "+group_speed_top.toFixed(9)+" μm/fs = "+c0toGroupSpeedTop.toFixed(3)+"\u00B7c0",pozX1+9,pozY3+6,ctx1,DPmm); 			
				fillTextkaro("Δω/Δk[\u2B07]= "+group_speed_bot.toFixed(9)+" μm/fs = "+c0toGroupSpeedBot.toFixed(3)+"\u00B7c0",pozX1+9,pozY3+7		,ctx1,DPmm); 
			




				ctx1.stroke();	
			}

		
};

function getDispersiveN(n,fTHz,dispersivity) {
	//return (n+((fTHz-300)/300)*dispersivity);					// n is linearly related to f
	//return (n+Math.pow(fTHz/370,30));					// n is linearly related to f
	return (n+Math.pow(fTHz/100*n,dispersivity/2))
}

function calculateReflectance(n1,n2,thetaRad,pol_choice) {
		// FRESNEL FERSNEL FRESNEL's equations for non-magnetic transparent material Z=f(epsilon)
		// This is for E field on s plane, for power it has to be.. squared
		// IT depends on polarization on the incoming wave
				// Sneels Law

		var thetaRefr=Math.asin(Math.sin(thetaRad)*n1/n2);								// ANGLE OF REFLECTED RAY
		
		if (pol_choice==0) {				// This is for E field on p plane, for power it has to be.. squared
			var RpTOP=n1*Math.cos(thetaRefr) - n2*Math.cos(thetaRad);
			var RpBOT=n1*Math.cos(thetaRefr) + n2*Math.cos(thetaRad);
			var Rp=Math.pow(RpTOP/RpBOT,2);
			var R=Rp;
			var T=1-Rp;	
			
		} else if (pol_choice==1) {
			var RsTOP=Math.abs(n1)*Math.cos(thetaRad) - Math.abs(n2)*Math.cos(thetaRefr);
			var RsBOT=Math.abs(n1)*Math.cos(thetaRad) + Math.abs(n2)*Math.cos(thetaRefr);
			var Rs=Math.pow(RsTOP/RsBOT,2);										
			var R=Rs;
			var T=1-Rs;												// E field amplitude reduced by?		
		} else {
			alert("I dun goffed! Something wrong with the choice of polarisation in the code");
		}
	
	return T;
}

function draw2rays(fTHz,raylength,locX,locY,Amp,n1,n2,ctx1) {
//--- WAVES---


	// DOES THE USER WANT TO CHANGLE The lenght of refracted wave?	
	// Check if DIV ELEMENT EXISTS; IF NOT; JUST USE DEFAULT
	if (document.getElementById("range_refracted_raylenght") === null) {  // IF IT IS DEFINED?
		var refracted_raylenght=raylength;
	} else { 
		var refracted_raylenght=document.getElementById("range_refracted_raylenght").value;
		document.getElementById("value_refracted_raylenght").innerHTML=refracted_raylenght

	}
	

	// INCOMING WAVE
		// GET WAVE LENGTH

		
		// GET THETA ANGLE FROM USER					
		theta1=document.getElementById("theta1").value/10;
		document.getElementById("value_theta1").innerHTML=theta1*10;
		var thetaRad=Math.PI/180*(theta1);								// Theta in radians
		var tilt=90-theta1;												// Angle from horizontal line... because Javascript
		
		
	// Starting point of the incoing way is ray_length away from the central point
		var xStart=locX-raylength*DPmm*Math.cos(tilt*Math.PI/180);
		var yStart=locY-raylength*DPmm*Math.sin(tilt*Math.PI/180);		
		
	var arrayTopRay=drawRay(fTHz,raylength,Amp,ctx1,xStart,yStart,tilt,0,n1,0);


	//!!!!!!!!!!!!!!!!!
	// REFRACTED WAVE
		//  Strating point of refracted wave is the ending point of incoming wave
			var xEndWave1 = xStart+raylength*DPmm*Math.cos(tilt*Math.PI/180);
			var yEndWave1 = yStart+raylength*DPmm*Math.sin(tilt*Math.PI/180);
			
		// Sneels Law
			var theta2rad=Math.asin(Math.sin(thetaRad)*n1/n2);	
			var tilt2=90-theta2rad*180/Math.PI;										// Tilt is used for javascirpt canvas rotation
		
		// FRESNEL FERSNEL FRESNEL's equations for non-magnetic transparent material Z=f(epsilon)
		// This is for E field on s plane, for power it has to be.. squared
		// IT depends on polarization on the incoming wave
		var pol_choice=document.getElementById("range_polarisation").value;
		if (pol_choice==0) {				// This is for E field on p plane, for power it has to be.. squared
			var RpTOP=Math.abs(n1)*Math.cos(theta2rad) - Math.abs(n2)*Math.cos(thetaRad);
			var RpBOT=Math.abs(n1)*Math.cos(theta2rad) + Math.abs(n2)*Math.cos(thetaRad);
			var Rp=Math.pow(RpTOP/RpBOT,2);
			var R=Rp;
			var T=1-Rp;	
			
		} else if (pol_choice==1) {
			var RsTOP=Math.abs(n1)*Math.cos(thetaRad) - Math.abs(n2)*Math.cos(theta2rad);
			var RsBOT=Math.abs(n1)*Math.cos(thetaRad) + Math.abs(n2)*Math.cos(theta2rad);
			var Rs=Math.pow(RsTOP/RsBOT,2);										
			var R=Rs;
			var T=1-Rs;												// E field amplitude reduced by?		
		} else {
			alert("I dun goffed! Something wrong with the choice of polarisation in the code");
		}

		
		// Calculating the phase of ray 2 - bacause our refracted wave is simulated as a new ray and I have to know at what phase the ray 1 ends
			var wave1_wavelength=calculate_wavelenght(fTHz,n1);
			var wave2_phase=calculate_border_phase(raylength,wave1_wavelength);
		
		// IF TOTAL REFLECTION OCCURS - Ignore fresnell equations completelly
			if (isNaN(theta2rad)) {	
				var R=1;			
			} 
			
		// Power to E-field
			var Re=Math.sqrt(R);
			var Te=Math.sqrt(T);
	
		// delay of ray2 because waiting on ray1.. depends only on the speed of light. so t=c/distance
		var tdelay=calculateTravelTime(raylength,n1);
		
		// DRAW RAY 2 ---------------
		var arrayBottomRay=drawRay(fTHz,refracted_raylenght,Amp*Te,ctx1,xEndWave1,yEndWave1,tilt2,wave2_phase,n2,tdelay);



	//!!!!!!!!!!!!!!!!!
	//  REFLECTED WAVE - only if enabled
	if (document.getElementById("showReflecterRay").checked==1) {
		var theta3rad = thetaRad-Math.PI/2;
		var tilt3=theta3rad*180/Math.PI;
		
		//drawRay(fTHz,raylength,Amp,ctx1,xStart,yStart,tilt,0,n1,0);
		
		

		// IF WE ARE AT P PLANE POLARIZATION AND THETA = AT BREWSTERS ANGLE; DON?T SHOW A WAVE:::(remove straight line)
		if (document.getElementById("range_polarisation").value==0 && theta1 == findBresterAngle(n1,n2)) {
			var arrayReflected=new Array();			// Empty array - there is no array one under brewsters angle. This id done because otherwise it draws zeros on the plane.
		} else  {
			var arrayReflected=drawRay(fTHz,raylength,Amp*Re,ctx1,xEndWave1,yEndWave1,tilt3,wave2_phase,n1,tdelay);

		}
		
	} else {
		var arrayReflected=new Array();  // Empty array
	}




		// return top and bottom rays
		return [arrayTopRay,arrayBottomRay,arrayReflected];

}

// FUNCTION THAT ACTUALLYD DRAWS THE WAVES
function drawRay(fTHz,raylength,Amp,ctx1,xStart,yStart,tilt,phaseShift,n,tdelay) {

	// Defined
	var c0=299792458										// Speed of light - meters per second OR micrometers per microsecond
	var c0mmpatts=299792458/Math.pow(10,12)					// micro - nano - piko - femto - atto .. 12 zeroes. micrometers/attoseconds (Should be a number around 50 for 10 micrometers)
	var array_wave=new Array();
			
	// Rotatino around which point?		
	var rotatex = xStart;									// By default the rotation is around the starting point of the wave
	var rotatey = yStart;		
				
	// Pulled 		
	var fTHz;												// f in TeraHerz 10^12
	var raylength;											// length of wave in micrometers in the direction of movement for presentation purposes)
	var Amp;												// Wave Amplitude - has no meaning, just to make it nice on the canvas
			
	// Calculated		
	var raytime = raylength*n/c0mmpatts;					// time for wave to travel the defined length
	var lambda1=calculate_wavelenght(fTHz,n);				// get vavelenght in micrometers
	var numPeriodsToDraw=raylength/lambda1;					// depends on the length of the distance traveled
	var w11=2*Math.PI*fTHz/Math.pow(10,6);					// Angular speed in rad/attoseconds		
			
	// START DRAWING WHERE?
	ctx1.moveTo(xStart,yStart);	

	// ROTATE DRAWN IMAGE AROUND WHICH POINT (for the angle - theta of wave)
	// Basically this thing draws wave in x diretin then rotates it to avoid cartezian converions.
	ctx1.translate(rotatex,rotatey);		
	ctx1.rotate(tilt * Math.PI / 180);
	ctx1.translate(-rotatex,-rotatey);
	
	// Calculated
	var lambda1=calculate_wavelenght(fTHz,n);				// get vavelenght in micrometers
	var k1 = 2*Math.PI/lambda1;								// Wavenumber in 1/micrometers
	
	
	// THIS SIMULATES WAVE IS APPROACHING TO THE SUFACE.
	
	if (t<=raytime+tdelay)	{
		var how_many_samples=(t-tdelay)*sampling*c0mmpatts/n			// t [attosec] * sampling [samples/micrometer] * c0mmpatts / n [um/attosec]
	} else {
		var how_many_samples=sampling*raylength;			// if 12 micrometers, then 12*sampling
	}
	
	for (var i=0;i<=how_many_samples;++i) {	// All is relative to wavelenght

		// SAMPLING SIZE - this represent the wave from 
		var x=i*1/sampling;							
		var mmppx=x*DPmm									// StretchFactor (How many pixels represents a micrometer of a wavelenght
		


		// -- MAIN FUNCTION
		//--------------------  													//The eqation represents a signal which is infinteley long, has allways and will exist. When presenting this on canvas
		var f1=Amp*Math.sin(k1*x-w11*t+phaseShift);									// i am movinb both with time as well as with direction, since I am seeing the wave moving. 
		//var f1 = wave_equation(Amp,k1,x,w11,t,phaseShift);						// The infinite ray is drawn an frozen every delat_t. How much did the wave move at this deltat? c=dl/dt --> dtl=c*dt
		// Save the wave_form?
		array_wave[i]=f1;
		//--------------------
		
		//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		//putRayOnCanvas(xStart,yStart,mmppx,f1,ctx1);
		putRayOnCanvas(xStart,yStart,mmppx,f1,ctx1);
		//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		// Returns the whole wave it just made
	}

	// Rotate K.O. back
	ctx1.translate(rotatex,rotatey);
	ctx1.rotate(-tilt * Math.PI / 180);
	ctx1.translate(-rotatex,-rotatey);	
	
	// Return the array if you want it.
	return array_wave;
}

// Calculates f(x) like a million times
function wave_equation(Amp,k1,x,w11,t,phaseShift) {
	return Amp*Math.sin(k1*x-w11*t+phaseShift);
}

function drawMathPaper(block_startX,block_startY,blocks_vertical,blocks_horizontal,block_width,ctx) {
	ctx.beginPath();
    ctx.strokeStyle = '#909090';
	ctx.setLineDash([1, 3]);/*dashes are 5px and spaces are 3px*/
	ctx.beginPath();
	  
	for (var i=0;i<=blocks_horizontal;i++) {
	  ctx.moveTo(block_startX,block_startY+i*block_width);
	  ctx.lineTo(block_startX+block_width*blocks_vertical,block_startY+i*block_width);
	  ctx.stroke();
	}

	for (var i=0;i<=blocks_vertical;i++) {
	  ctx.moveTo(block_startX+i*block_width,block_startY);
	  ctx.lineTo(block_startX+i*block_width,block_startY+block_width*blocks_horizontal);
	  ctx.stroke();
	}
}

function putRayOnCanvas(xStart,yStart,mmppx,f1,ctx1) {

	// Make the wave look like it's travelling from 0 without modifying the equation

			
		// This little fella is very CPU hungry. Optmize? Who has time for that, just wait 18 months  and it'll be twice faster!
		if(document.getElementById("markFields").checked == '1'){	// So what's the logic with this stroke... The color is predefined before this fucntion is called, So gotta draw everything that was calcualted so far, end that draw, change contex color and start a new one. God...
			ctx1.stroke();
			
			// JAvascript faster with fixed number.
			// Normalization with Amplitude of the Incoming wave! Now how am I going to get that in here...global variable again..
			var incoming_ray_amp=wave1[2];
			var temp_f1=Math.floor((((f1/incoming_ray_amp)+1)/2)*7);			// Basically puts the values between 0 and 7--8bit color code			
			
			switch (temp_f1) {
			  case (0):
				ctx1.strokeStyle = '#FBEFEF';	
				break;
			  case (1):
				ctx1.strokeStyle = '#F8E0E0';	
				break;
			  case (2):
				ctx1.strokeStyle = '#F6CECE';	
				break;
			  case (3):
				ctx1.strokeStyle = '#F5A9A9';	
				break;
			  case (4):
				ctx1.strokeStyle = '#F78181';	
				break;
			  case (5):
				ctx1.strokeStyle = '#FA5858';	
				break;
			  case (6):
				ctx1.strokeStyle = '#FE2E2E';	
				break;
			  case (7):
				ctx1.strokeStyle = '#FF0000';	
				break;
			}	
			ctx1.beginPath();
			ctx1.rect(xStart+mmppx,yStart-25,0.5,50);			// Makes lines
			//ctx1.rect(xStart+mmppx,yStart+f1, 1, 1);			// Makes dots
		}		
		
		if(document.getElementById("markWaves").checked == '1'){	
			//ctx1.stroke();
			//ctx1.strokeStyle = 'blue';	
			//ctx1.beginPath();
			ctx1.rect(xStart+mmppx,yStart+f1, 0.1, 0.1);			// Makes dots
		}
		
		if(document.getElementById("markFronts").checked == '1'){	
			//ctx1.stroke();
			//ctx1.strokeStyle = 'purple';	
			ctx1.lineTo(xStart+mmppx,yStart+f1);			// Connets lines
		}
		
		
}

function sumArrays(array1,array2) {				// Sets the same size for arrays then adds them togehter
	// make arrays size equal, prevent NaNs
	var size_diff=array2.length-array1.length;
	
	for (var i=0;i<Math.abs(size_diff);i++) { 
		if (size_diff>0) {
			array1.push(0);
		} else if (size_diff<0){
			array2.push(0);
		}
	}
	
	// SUM both arrays together... thank you https://stackoverflow.com/questions/5760058/how-to-return-multiple-arrays-from-a-function-in-javascript
	var waveRefSum = array1.map(function (num, idx) {
		return num + array2[idx];
	});	
	
	return waveRefSum;
}

// DRAW SUMMED WAVE FROM ARRAYS
function drawSummedRayfromArray(arrays1,arrays2,locX,locY,raylength,ctx1) {
//--- WAVES---
	// Get arrays:
	var wave1incoming=arrays1[0];
	var wave1refracted=arrays1[1];
	var wave1reflected=arrays1[2];

	var wave2incoming=arrays2[0];
	var wave2refracted=arrays2[1];
	var wave2reflected=arrays2[2];
		
	// GET THETA ANGLE FROM USER					
	var theta1=document.getElementById("theta1").value/10;
	document.getElementById("value_theta1").innerHTML=theta1*10;
	
	var thetaRad=Math.PI/180*(theta1);								// Theta in radians
	var tilt=90-theta1;												// Angle from horizontal line... because Javascript

	//!!!!!!!!!!!!!!!!!		
	// INCOMING WAVE - incoming waves are always at the same angle
		// SUM UP 2 arrays -- thank you https://stackoverflow.com/questions/5760058/how-to-return-multiple-arrays-from-a-function-in-javascript
		var waveIncSum=sumArrays(wave1incoming,wave2incoming);

		// Starting point of the incoing wave is ray_length away from the central point
		var xStart=locX-raylength*DPmm*Math.cos(tilt*Math.PI/180);
		var yStart=locY-raylength*DPmm*Math.sin(tilt*Math.PI/180);		
				

	drawRayfromArray(raylength,xStart,yStart,tilt,waveIncSum,ctx1);
	
	
	//!!!!!!!!!!!!!!!!!
	// REFRACTED WAVE - refracted rays ae not always at the same angle!
		// SUM UP 2 ARRAYS - only if the angle is the same for both .. eg  if the medium is not dispersive!
	
	//  Strating point of refracted and reflected wave is the ending point of incoming wave
	var xEndWave1 = xStart+raylength*DPmm*Math.cos(tilt*Math.PI/180);
	var yEndWave1 = yStart+raylength*DPmm*Math.sin(tilt*Math.PI/180);

	// angle of refraction for frist ray
	var theta2radWAVE1=Math.asin(Math.sin(thetaRad)*n1ray1/n2ray1);	
	var tilt2_1=90-theta2radWAVE1*180/Math.PI;										// Tilt is used for javascirpt canvas rotation

	var theta2radWAVE2=Math.asin(Math.sin(thetaRad)*n1ray2/n2ray2);	
	var tilt2_2=90-theta2radWAVE2*180/Math.PI;										// Tilt is used for javascirpt canvas rotation

		// SHOW SUMMED RAY ONLY IF THEY ARE IN THE SAME DIRECTION
		if (theta2radWAVE1==theta2radWAVE2) {
			theta2rad=theta2radWAVE1;
		
			// ADD waves together
			// make arrays size equal, preventNaNs
			var waveRefSum=sumArrays(wave1refracted,wave2refracted);
			drawRayfromArray(raylength,xEndWave1,yEndWave1,tilt2_1,waveRefSum,ctx1)
		} else {	// SHOW BOTH RAYS
		drawRayfromArray(raylength,xEndWave1,yEndWave1,tilt2_1,wave1refracted,ctx1)
		drawRayfromArray(raylength,xEndWave1,yEndWave1,tilt2_2,wave2refracted,ctx1)				
		}
		
		
	//!!!!!!!!!!!!!!!!!
	// REFLECTED WAVE
		// Disable by choice
		
		// SUM UP 2 arrays -- thank you https://stackoverflow.com/questions/5760058/how-to-return-multiple-arrays-from-a-function-in-javascript
		var waveReflSum=sumArrays(wave1reflected,wave2reflected);

		var theta3rad = thetaRad-Math.PI/2;
		var tilt3=theta3rad*180/Math.PI;			
		
	drawRayfromArray(raylength,xEndWave1,yEndWave1,tilt3,waveReflSum,ctx1)

}

// DRAW RAY FROM ARRAY - for the summed wave
function drawRayfromArray(raylength,xStart,yStart,tilt,array_wave,ctx1) {
	// Rotating around which point?		
	var rotatex = xStart;									// By default the rotation is around the starting point of the wave
	var rotatey = yStart;		
				
	// Pulled 	
	// START DRAWING WHERE?
	ctx1.moveTo(xStart,yStart);	

	// ROTATE DRAWN IMAGE AROUND WHICH POINT (for the angle - theta of wave)
	ctx1.translate(rotatex,rotatey);		
	ctx1.rotate(tilt * Math.PI / 180);
	ctx1.translate(-rotatex,-rotatey);
	
	for (var i=0;i<=array_wave.length;++i) {

		var x=i*1/sampling;							
		var mmppx=x*DPmm									// StretchFactor (How many pixels represents a micrometer of a wavelenght
		var f1=array_wave[i]
		
		putRayOnCanvas(xStart,yStart,mmppx,f1,ctx1)
	}

	// Rotate K.O. back
	ctx1.translate(rotatex,rotatey);
	ctx1.rotate(-tilt * Math.PI / 180);
	ctx1.translate(-rotatex,-rotatey);	
	
	// Return the array if you want it.
}

function calculate_wavelenght(fTHz,n) {						// Takes n and f in Thz
	var c0mmpms=299792458									// kilometers per second == milimeters per microseconds
	var lambda_micrometers=c0mmpms/n/fTHz/1000000;			// in micrometers
	return lambda_micrometers;
}

function calculate_border_phase(distance_travelled,lambda) {	

	// What is the wavelenght of the wave?					2.0 um
	// lambda

	// What is the distance travelled in micrometers?  		6.8 um
	// distance_travelled.			

	// How many lambdas fit in to the distance traveled?	3.4
	var hmlfittd = distance_travelled/lambda;
	
	// How many whole lambdas fit in to this distance?		3
	var hmlfittd_whole=Math.floor(hmlfittd);
	
	// And the difference that doesnt fit is??				0.4 of a lambda
	var hmlfittd_left=hmlfittd-hmlfittd_whole;
	
	// And in radians, how much is that?					0.4*2PI
	var phase = hmlfittd_left*2*Math.PI;											

	return phase;
}

function pause_time() {
	if (document.getElementById("button_pause").value==0) {		// When clicking UNPAUSE TIME
		document.getElementById("button_pause").innerHTML="STOP"
		stopwatch1=t;															// Remember wheny ou clicked pause for the stopwatch
		document.getElementById("button_pause").value=1;						
		
	} else {
		document.getElementById("button_pause").innerHTML="START"
		document.getElementById("button_pause").value=0

	}
}

function reset_time() {
	t=0;
	stopwatch1=0;
}

function THZ2aas (fTHz) {  // Terahertz to atoseconds
	return 1/fTHz*1000000;
}

function calculateTravelTime(distanceInMicrometers,n) {
	var c0mmpus=299792458/n;							// meters per second = micrometers per microsecond
	var timeinatts=distanceInMicrometers/(c0mmpus);		// delay in microseconds
	return timeinatts*Math.pow(10,12);					// delay in attoseconds
}


function findCriticalAngle(n1,n2) {
	// get n2 and n2..from global if arguments weren't passed -- button in html needs this.
	if (n1 === undefined) {
		var n1=n1ray1;
		var n2=n2ray1;
	} 
	
	// get n2 and n2
	var criticalAngle=Math.asin(n2/n1);
	
		// If not possible to calculate
		if (isNaN(criticalAngle)) {	
			//alert("No Critical Agnle exists");
		} 
	var criticalAngleDeg=Math.ceil((criticalAngle*180/Math.PI)*10)/10;
	return criticalAngleDeg;
}

function setCriticalAngle() {

	var criticalAngleDeg=findCriticalAngle();
	
	
	if (isNaN(criticalAngleDeg)) {	
		return;
	} else {
	document.getElementById("message_noCriticalAngle").innerHTML="";
	document.getElementById("theta1").value=criticalAngleDeg*10	
	}	
	


	// Calculate total reflectino angle
}

function findBresterAngle(n1,n2) {
	// get n2 and n2..from global
	if (n1 === undefined) {
	var n1=n1ray1;
	var n2=n2ray1;
	} 

	var brewsterAngle=Math.atan(Math.abs(n2)/Math.abs(n1));
	
		// If not possible to calculate
		if (isNaN(brewsterAngle)) {	
			//alert("No Brewster Angle exists");
		} 
		
	var brewsterAngleDeg = Math.ceil(brewsterAngle*180/Math.PI*10)/10;		// Accurate by 0.1 degree
	return brewsterAngleDeg;
	// Calculate total reflectino angle
}


function setBrewsterAngle() {
	var brewsterAngleDeg=findBresterAngle();
	document.getElementById("theta1").value=brewsterAngleDeg*10;
	// Calculate total reflectino angle
}
function setThetaAngle(angle_deg) {
	document.getElementById("theta1").value=angle_deg;
}

function setFrequencyRay1(fTHz) {
	document.getElementById("range_frequency1").value=fTHz;
}


// DOWNLOAD CANVASES https://stackoverflow.com/questions/29551841/merge-multiple-canvases-and-download-as-image
// https://stackoverflow.com/questions/11112321/how-to-save-canvas-as-png-image
function downloadCanvas() {


	var canvas = document.getElementById("test_canvas");
	canvas.width=canvasWidth;
	canvas.height=canvasHeight;
	
	var ctx = canvas.getContext("2d");
	ctx.fillStyle = "white";
	ctx.fillRect(0, 0, canvas.width, canvas.height);




  var backgroundCanvas = document.getElementById('background_canvas');
  var whiteCanvas = document.getElementById('test_canvas');
  var animatedCanvas = document.getElementById('myCanvas');

  var bottleContext = whiteCanvas.getContext('2d');
  bottleContext.drawImage(backgroundCanvas, 0, 0);
  bottleContext.drawImage(animatedCanvas, 0, 0);

  var dataURL = whiteCanvas.toDataURL("image/png");
  var link = document.createElement('a');
  link.download = "ŽAREK.png";
  link.href = whiteCanvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
  link.click();
}


function drawLineWithArrows(x0,y0,x1,y1,aWidth,aLength,arrowStart,arrowEnd,ctx){ https://riptutorial.com/html5-canvas/example/18136/line-with-arrowheads
// x0,y0: the line's starting point
// x1,y1: the line's ending point
// width: the distance the arrowhead perpendicularly extends away from the line
// height: the distance the arrowhead extends backward from the endpoint
// arrowStart: true/false directing to draw arrowhead at the line's starting point
// arrowEnd: true/false directing to draw arrowhead at the line's ending point
 
	var dx=x1-x0;
    var dy=y1-y0;
    var angle=Math.atan2(dy,dx);
    var length=Math.sqrt(dx*dx+dy*dy);
    //
    ctx.translate(x0,y0);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(length,0);
    if(arrowStart){
        ctx.moveTo(aLength,-aWidth);
        ctx.lineTo(0,0);
        ctx.lineTo(aLength,aWidth);
    }
    if(arrowEnd){
        ctx.moveTo(length-aLength,-aWidth);
        ctx.lineTo(length,0);
        ctx.lineTo(length-aLength,aWidth);
    }
    //
    ctx.stroke();
    ctx.setTransform(1,0,0,1,0,0);
	ctx.beginPath();			// I can't stroke before I transform...
	
}

// FUNCTION JUST FOR PRESENTATION PURPOSES
// -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
function setSignalSimulationParameters(reset_time,radio_id_manual,markFronts,showReflecterRay,range_refracted_raylenght,range_frequency1,range_frequency2,theta1,range_n1,range_n2,range_n2z2) {

	if (reset_time) {
		t=0;
	}

document.getElementById("radio_id_manual").checked=radio_id_manual
document.getElementById("markFronts").checked=markFronts
document.getElementById("showReflecterRay").checked=showReflecterRay

document.getElementById("range_refracted_raylenght").value=range_refracted_raylenght
document.getElementById("range_frequency1").value=range_frequency1
document.getElementById("range_frequency2").value=range_frequency2
document.getElementById("theta1").value=theta1

document.getElementById("range_n1").value=range_n1
document.getElementById("range_n2").value=range_n2
document.getElementById("range_n2z2").value=range_n2z2

//setSignalSimulationParameters(1,1,1,23,446,370,0,105,115,149)
//setSignalSimulationParameters(1,1,1,23,446,330,0,105,133,157)
}


</script>

<body onLoad="init();">


TEST A:<span id="test1">ready</span></br>
TEST B:<span id="test2">ready</span></br>
TEST C:<span id="test3">ready</span> <br />

 <div id="overlay_parent">
	 <div id="overlay_content">
		<div class="row">	
			<b> | IDEALNO ENOBARVNA | LINEARNO POLARIZIRANA |  NESKONČNO OZKA | SVETLOBNA | TEM ŽARKA | Z NUMERIČNO APERTURO NIČ |  
			KI PRESTOPATA MEJO DVEH RAZLIČNIH (disperzivnih ali nedisperzivnih) MATERJALOV, OPISANA Z VALOVNO TEORIJO SVETLOBE. 
			(torej - v naravi neobstoječa)
		</div>
		<!-- SIMULACIJA -->
		<div class="row">


				<!-- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -->
				<!-- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -->
			<div class="column" id="levi">					
					<h2>SIMULACIJA</h2>
					<button id="button_reset" onclick="reset_time()">t = 0</button>
					<button id="button_pause" value="1" onclick="pause_time()">STOP</button> <br /><br />
					<b>Čas: </b><span id="value_time"></span> femtosekund <br>
					<b>Štoparica:<b/> <span id="value_timer"></span>  fs<br />

				<br />
					Hitrost: <span id="value_speed"></span>x <br />
					<input type="range" id="range_speed" min="1" max="40" value="20">
				<br />
				
				<br />
					Število vzorcev na mikrometer:<span id="value_sampling"></span> <br />
					<input type="range" id="range_sampling" min="1" max="300" value="60">
				<br />

				
				<br />
					Dolžina lomnega žarka:<span id="value_refracted_raylenght"></span>μm <br />
					<input type="range" id="range_refracted_raylenght" min="1" max="23" value="7">
				<br />


				<br />
				Skrij odbojni žarek: <input type="checkbox" id="showReflecterRay" checked="checked"> 
				<br />
				
				<br />
				Prikaži izračune: <input type="checkbox" id="showCalculations" checked="checked"> 
				<br />


				<hr />
				<!-- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -->
				<!-- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -->
				<h2>ŽARKI</h2>
				<b>Frekvenca žarka 1:</b> <span id="value_frequency1"></span> THz <br />
				<input type="range" id="range_frequency1" min="0" max="900" value="460"> <br/>
				
				<b>Frekvenca žarka 2</b>: <span id="value_frequency2"></span> THz <br />
				<input type="range" id="range_frequency2" min="0" max="900" value="370"> <br/>
				
				θ - kot Theta: <span id="value_theta1"></span>° <br />
				<input type="range" id="theta1" min="0" max="900" value="250"></br>
				<br/>
				<button id="button_totalref" onclick="setCriticalAngle();">Kritični kot žarka 1</button>  &nbsp; &nbsp;
				<button id="button_totalref" onclick="setBrewsterAngle();">Brewsterjev kot žarka 1</button> &nbsp; &nbsp;
				<button onclick="setThetaAngle(0)">Theta=0</button></br>

				<i><span id="message_noCriticalAngle" color="red"></span></i>
				<br /><br />
				
				Polarizacija obeh žarkov <br />
				P <input type="range" id="range_polarisation" width"50" min="0" max="1" value="0"> S 
				
				<br />
				<br />
				
				Točke: <input type="radio" name="pointsOrFronts"  id="markWaves" checked="0"> | 
				Povezane točke: <input type="radio" name="pointsOrFronts"  id="markFronts" checked="1"> |
				Polja: <input type="radio" name="pointsOrFronts" id="markFields" checked="1"> 				
				
				<br />
				<br />

				<hr />
				<!-- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -->		
				<!-- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -->
				<h2>MATERJAL</h2>
					<b>Lomni količnik zgornjega medija: n1:</b> <span id="value_n1"></span> <br />
					<input type="range" id="range_n1" min="-10" max="300" value="160"></br>
					
					<b>Lomni količnik spodnjega medija: n2:</b> <span id="value_n2"></span> <br>
					<input type="range" id="range_n2" min="10" max="300" value="100"></br>
					<br />			
					
					<span id="hidden_2nz2">
						<b>Lomni količnik spodnjega medija za žarek 2:</b> <span id="value_n2z2"></span> <br>
						<input type="range" id="range_n2z2" min="10" max="300" value="100"></br>
					</span>
					
					
					
				<!-- Dispersivity -->
				<span id="hidden_dispersivity"">
					  <span onMouseOver="document.getElementById('popup_dispersitivity').style.display='block'" onMouseOut="document.getElementById('popup_dispersitivity').style.display='none'">
							<b>Faktor disperzije [?]</b>
					  </span>
							<!-- POPUPT:  FAKTOR DISPERZIJE: -->
						  <span id="popup_dispersitivity" class="white_content">
							<b>
								Odvisnost lomnega količnka je odvisna od frekvence signala na sledeč način:<br/><br />
								n2 + Math.pow(fTHz/100*n2,faktor-disperizje/2)<br /><br />
								ZAKAJ?  TESTING---					  
					  
							</b>
						</span>		

					  
					  
					<br />
					<input type="range" id="range_dispersion" min="1" max="10" value="1"><span id="value_randgedispersion"></span></br>
					<br />
				</span>
				
					<input type="radio"name="radio_dispersion" checked="checked" value="0">	Oba medija brez disperzije </input><br>
					<input type="radio"name="radio_dispersion" value="1" id="radio_id_onlytopdispersive">					Gornji medij disperziven</input><br>
					<input type="radio"name="radio_dispersion" value="2" id="radio_id_onlybottmdispersive">					Spodnji medij disperziven </input><br>
					<input type="radio"name="radio_dispersion" value="3" id="radio_id_bothdispersive">					Oba medija disperzivna</input><br>
					<input type="radio"name="radio_dispersion" value="4" id="radio_id_specialmedium">	Poseben namišljeni medij 									
						<span onMouseOver="document.getElementById('popup_specialmedia').style.display='block'" onMouseOut="document.getElementById('popup_specialmedia').style.display='none'">
							<b>[?]</b>
						</span>
							<!-- POPUPT:  SPECIAL MEDIA: -->
						  <span id="popup_specialmedia" class="white_content">
							<b>
								Ta nimšljen medij je tak, da ima enako valovno dolžino ne glede na frekvenco.<br /><br />
								ZAKAJ?: Da se jasno vidi, da valovna dolžina ni tisto kar določa barvo (v naših očeh), pač pa frekvenca.
							</b>
						</span>						
					</input><br>
					
					<input type="radio" name="radio_dispersion" value="5" id="radio_id_manual"> Ročno nastavi n2 za žarek 
						<span onMouseOver="document.getElementById('popup_manual').style.display='block'" onMouseOut="document.getElementById('popup_manual').style.display='none'">
							<b>	2 [?]</b>
						</span>
							<!-- POPUPT:  ROČNI N: -->
						  <span id="popup_manual" class="white_content">
							<b>
								Odgovarja na vprašanje: <br /><br />
								Kaj če bi bil lomni količnik medija tak, da bi imel lomni količnik n1 pri frekvenci f1 in n2 pri frekvenci n2?<br/><br />
								<br /><br />
							</b>
						</span>		
					</input><br>

				
				
				<!-- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -->
				<!-- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -->
				<hr />
				<h2>BLIŽNJICE</h2>
				
				
				<button onclick="downloadCanvas()"> IZVOZI V PNG</button><br />
				<button onclick="setSignalSimulationParameters(0,1,1,1,23,446,370,0,105,115,149)"> Negativna skupinska hitrost1</button><br />
				<button onclick="setSignalSimulationParameters(0,1,1,1,23,446,330,0,105,133,157)"> Skupinska hitrost višja od fazne</button><br />
				<button onclick="setGroupVelocityHigehrThanPhaseVelocity()"> </button>

				
				
				<br />
				<br />
				
						<span onMouseOver="document.getElementById('popup_tipkovnica').style.display='block'" onMouseOut="document.getElementById('popup_tipkovnica').style.display='none'">
							<b>	TIPKOVNICA: [?]</b>
						</span>
							<!-- POPUPT:  ROČNI N: -->
						  <span id="popup_tipkovnica" class="white_content">
							<b>
								UP ................Povečaj f1<br>
								DOWN................Zmanjšaj f1<br>
								LEFT................Povečaj vpadni kot<br>
								RIGHT................Pomanjšaj vpadni kot<br>
								SPACEBAR................Ustavi čas<br>
								T................Nastavi vpadni kot na 0<br>
								B................Nastavi Brewsterjev kot za žarek 1<br>
								V................Nastavi kritični kot za žarek 1<br>
								P................Spremeni polarizacijo<br>
								pika.............povečaj n2
								vejica...........pomanjšaj n2
								<br /><br />
							</b>
						</span>	
						
				<br><br>
				UP <br>
				DOWN<br>
				LEFT<br>
				RIGHT<br>
				SPACEBAR<br>
				T<br>
				B<br>
				V<br>
				P<br>
				

		 </div>
			
			<div class="column" id="desni">    
				<div id="zadej">
					<!-- OZADJE SIMULACIJE -->
					<canvas id="background_canvas"></canvas>
				</div>		    
				<div id="spredej">
					<!--  SIMULACIJA -->
					<canvas id="myCanvas">Your browser does not support the HTML5 canvas tag.</canvas>
					<a href="https://youtu.be/kMSgE62S6oo?t=117" style="float:right; font-size: 10px; color:gray;"> By the way, light is actually particles, not waves: https://youtu.be/kMSgE62S6oo?t=117</a>
				</div>
				
				
			

				<!-- MESSAGES IN THE POPUPS -->

					
					<!-- POPUP DISPERSITIVITY: ID=light -->
						 <span id="popup_dispersitivity" class="white_content">
								Dispersivity is a made-up property of a fictional material (could be real, I have no idea). 
								It tell how much the change of frequency changes therefraction index for that frequency.  
								By default, the equation to calculate n is: <br /><br />
						<span align="center"> n+((fTHz-300)/300)*dispersivity. </span><br /><br />
						 </span>
					  
					
				
				
				
				
			</div>
			
		</div>

		  <canvas id="test_canvas"></canvas>





	</div>
	<div id="overlay_popup">
	</div>
</div>


</body>
</html>
